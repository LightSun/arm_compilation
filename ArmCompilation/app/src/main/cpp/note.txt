arm官方文档
https://developer.arm.com/documentation/dui0802/a/A64-General-Instructions/ADD--extended-register-?lang=en
======== arm汇编 ===========
数据处理指令：
跳转指令：
程序状态寄存器访问:
加载/存储指令：
异常产生指令:
伪指令：

------- 传送 ------------
//arm64里面没有ro. 换之用x 和 w
MOV R1，R0   @ 将寄存器R0的值传送到寄存器R1
MOV PC，R14   @ 将寄存器R14的值传送到PC，常用于子程序返回
MOV R1，R0，LSL＃3 @ 将寄存器R0的值左移3位后传送到R1（即乘8）
MOVS PC, R14	  @ 将寄存器R14的值传送到PC中，返回到调用代码并恢复标志位
MVN R0，＃0   ；将 0取反 传送到寄存器R0中，完成后R0=-1（有符号位取反）




-------------- 传送/存储指令 --------------------  https://zhuanlan.zhihu.com/p/82490125 ================
加载寄存器的指令LDR(Load)
存储到寄存器的质量 STR(store)

"[]"相当于C语言里的"*" （指针），表示取地址里的内容。
假设R1里存放的是0x200，内存中地址0x200处的内容是0x5，那么"ldr r0, [r1]"就是将0x5放入r0中。

寄存器有限，so 使用寄存器基地址 + 偏移/索引  完成
STR  R0,[R1, #12]  // R0 --> [R1+12]
LDR  R4,[R5, R6]  // R4 <-- [R5+R6]

"预索引"(pre-index):
    传输前后寄存器R1的值都不会改变。
    "str r0, [r1, #12]"  //意思是r1的值 + 12后 存储到r0寄存器

"后索引"(post-index)：
    寄存器R1的值会变
"str r0, [r1], #12"就等同于"str r0, [r1]"加上"r1 = r1+12 //组合2条指令

// ======== STM, LDM用于 32位。armv7 ============
STM: 将多个寄存器的值传送到内存的相邻位置。 M代表multi
LDM： 反之（相对STM）
多个寄存器使用'｛｝'圈起来。 表示待传送的寄存器列表.
"STM R0, {R4,R5}" :  表示将r4的值存到R0的内存单元，R5存储到下一个内存单元

批量传输其实是存在一个方向问题的，为了区分下一个内存单元是在上一个单元的后面还是前面(地址更大还是更小)，
需要加上后缀"I"和"D"来分别表示"Increase"和"Decrease"。

还有一个问题，要将R5的值传送到下一个内存单元，需要首先获得这“下一个”内存单元的地址，这就涉及到地址的增减。
假设R0的值是0，如果先增加"0"这个值(在32位系统中，一次增加的值是4)，再传送R4，那么就是[0x4]=R4, [0x8]=R5；
如果是传送完R4后再增加"0"这个值，那么就是[0x0]=R4, [0x4]=R5。
所以还需要加上后缀"A"和"B"来分别表示"After"(传送后增加)和"Before"(传送前增加)。

因此，LDM/STM家族一共有"IA", "IB", "DA"和"DB"四个变种(variant)，"LDM"和"STM"什么后缀都不接也可以直接使用，
但它其实包含一个隐式规则，即默认为"IA"，也就是说"LDM"和"STM"其实分别等同于"LDMIA"和"STMIA"。

STMDB  SP!, {R0-R3,  LR}  <-->  PUSH  {R0-R3, LR}
LDMIA  SP!, {R0-R3,  PC}  <-->  POP  {R0-R3, PC}
SP: stack pointer . '!'表示传送前后SP的值变不变。
在入栈和出栈的时候自然是要移动的，所以这里用了"!"。

!"是表示寄存器自增/自减的，所以它并不局限于配合LDM/STM使用，
如果它用在STR指令中，比如"str r0, [r1, #12]!"，就相当于"str r0 [r1, #12]"加上"r1 = r1+12"，

----------- ARMv8 ---------
LDM/STM 被 LDP ，STP取代.  LDP和 STP要求和内存传送的寄存器不超过2个


================= 数据处理(eg: 位移) =============
----- 位移 -------
LSL: logic shift left
LSR: logic shift right
arm中只有算术右移指令。右移时，高位将被符号位代替。
REV: 反转所有bytes. eg: 大端转小端.
REV16: 每2个byte反转。
LSB， MSB： 比如0x10001100   低4位是 1100(从LSB取)  高4位是1000(从MSB取)
--- ARMv8 -64
REV32

--- 位操作: insert, extract, clear ----
BFI(Bit Field Insert):  从指定位数插入一个数。
BFX(Bit Field Extract)： 从指定位置抽取
BFC(Bit Field clear):  清除指定的位bit
"BFI W0, W1, #9, #6":  将W1寄存器的LSB端抽取6位插入到   W0寄存器第9位开始的位置（9-14）
"BFX W0, W1, #18, #7": 将W1寄存器的LSB 第18位开始抽取7位到 -> W0寄存器的低7位（LSB）
"BFC W1, WZR, #3, #4": 将W1寄存器的 第3位开始，总4个位，设置位0

====================== 跳转 ==========================
https://zhuanlan.zhihu.com/p/84951062
'B label':
'BX label':
"B"属于无条件跳转，跳就对了，如果跳转的目标地址不是由立即数直接给出，而是通过寄存器给出，那就应该使用"BX"。

ARMv8将通用寄存器的名称由"R"改成了"X"
有的时候，"B"后面还会跟上一个"L"，"L"代表记录函数返回地址的link register(R14/X30)，暗示接下来的跳转其实是一个子函数调用，类似于x86中的"call"指令。

https://azeria-labs.com/arm-conditional-execution-and-branching-part-6/